#!/usr/bin/env python3

import sys, time, logging
import signal_handler, o80, o80_pam, pam_mujoco, context
from pam_mujoco import mirroring
from lightargs import BrightArgs, Set, Range, Positive, FileExists


SEGMENT_ID_ROBOT_MIRROR = "simulated_robot"
MUJOCO_ID_MIRRORING = "mirroring"


def configure():
    config = BrightArgs(
        "pam mirroring: having an instance of pam_mujoco mirroring another robot"
    )
    config.add_option(
        "robot_type",
        str(pam_mujoco.RobotType.PAMY2),
        "type of the robot, pamy1 ({}) or pamy2 ({})".format(
            str(pam_mujoco.RobotType.PAMY1), str(pam_mujoco.RobotType.PAMY2)
        ),
        str,
    )
    config.add_option(
        "segment_id_real_robot",
        o80_pam.segment_ids.robot,
        "segment_id of the robot that should be mirrored",
        str,
    )
    config.add_option(
        "mujoco_id_mirroring",
        MUJOCO_ID_MIRRORING,
        "mujoco_id of the pam_mujoco instance that will mirror the other robot",
        str,
    )
    config.add_option("frequency", 300, "mirroring frequency", float, [Positive()])
    config.add_option(
        "shoot_ball", False, "if True, balls will be shot toward the racket", bool
    )
    config.add_option(
        "ball_period", 5, "period at which balls will be shot", int, [Positive()]
    )

    change_all = False
    config.dialog(change_all, sys.argv[1:])

    if config.robot_type not in [
        str(pam_mujoco.RobotType.PAMY1),
        str(pam_mujoco.RobotType.PAMY2),
    ]:
        print(
            "\nERROR:only values accepted for robot type: {} or {}\n".format(
                str(pam_mujoco.RobotType.PAMY1), str(pam_mujoco.RobotType.PAMY2)
            )
        )
        return configure()

    if config.robot_type == str(pam_mujoco.RobotType.PAMY1):
        config.robot_type = pam_mujoco.RobotType.PAMY1
    if config.robot_type == str(pam_mujoco.RobotType.PAMY2):
        config.robot_type = pam_mujoco.RobotType.PAMY2

    print()
    return config


def configure_simulation(
    robot_type,
    mujoco_id=MUJOCO_ID_MIRRORING,
    segment_id=SEGMENT_ID_ROBOT_MIRROR,
    graphics=True,
    use_ball=False,
):

    accelerated_time = False
    burst_mode = False

    robot = pam_mujoco.MujocoRobot(
        robot_type, segment_id, control=pam_mujoco.MujocoRobot.JOINT_CONTROL
    )

    if use_ball:
        ball = pam_mujoco.MujocoItem(
            "ball",
            control=pam_mujoco.MujocoItem.CONSTANT_CONTROL,
            contact_type=pam_mujoco.ContactTypes.racket1,
        )
        balls = (ball,)
        table = pam_mujoco.MujocoTable("table")
    else:
        balls = []
        table = None

    handle = pam_mujoco.MujocoHandle(
        mujoco_id,
        graphics=graphics,
        accelerated_time=accelerated_time,
        burst_mode=burst_mode,
        robot1=robot,
        balls=balls,
        table=table,
    )

    return handle


class BallManager:
    def __init__(self, handle, period):
        self._handle = handle
        self._ball_interface = handle.interfaces["ball"]
        self._period = period
        self._last_ball = time.time()
        self._trajectory_reader = context.BallTrajectories()

    def perform(self):
        t = time.time()
        if t - self._last_ball < self._period:
            return
        self._last_ball = t
        _, trajectory_points = self._trajectory_reader.random_trajectory()
        self._ball_interface.play_trajectory(trajectory_points, overwrite=True)
        self._handle.reset_contact("ball")


def run():

    config = configure()
    use_ball = config.shoot_ball
    ball_period = config.ball_period

    log_handler = logging.StreamHandler(sys.stdout)
    logging.basicConfig(
        format="[pam mirroring {} {}] %(message)s".format(
            config.segment_id_real_robot, config.mujoco_id_mirroring
        ),
        level=logging.DEBUG,
        handlers=[log_handler],
    )

    logging.info(
        "creating o80 frontend to the robot to mirror: {}".format(
            config.segment_id_real_robot
        )
    )
    pressures = o80_pam.o80Pressures(config.segment_id_real_robot)

    logging.info(
        "creating o80 frontend to the mirroring robot (use_ball): {} ({})".format(
            config.mujoco_id_mirroring, use_ball
        )
    )

    mirroring_handle = configure_simulation(
        config.robot_type, mujoco_id=config.mujoco_id_mirroring, use_ball=use_ball
    )
    joints = mirroring_handle.interfaces[SEGMENT_ID_ROBOT_MIRROR]
    if use_ball:
        logging.info("creating ball manager")
        ball_manager = BallManager(mirroring_handle, ball_period)

    logging.info("creating frequency manager")
    frequency_manager = o80.FrequencyManager(config.frequency)

    logging.info("starting")

    signal_handler.init()  # for detecting ctrl+c
    try:
        while not signal_handler.has_received_sigint():
            try:
                _, __, joint_positions, joint_velocities = pressures.read()
                print(
                    "{:.2f} {:.2f} {:.2f} | {:.2f} {:.2f} {:.2f}".format(
                        *joint_positions, *joint_velocities
                    )
                )
                joints.set(
                    joint_positions, joint_velocities, duration_ms=None, wait=False
                )
                if use_ball:
                    ball_manager.perform()
            except Exception as e:
                logging.info("exception: {}. keyboard interrupt ? ".format(e))
                break
            frequency_manager.wait()
    except KeyboardInterrupt:
        logging.info("keyboard interrupt, exiting")

    logging.info("exit")
    print()


if __name__ == "__main__":

    run()
